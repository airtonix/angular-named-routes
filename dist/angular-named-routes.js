// Generated by CoffeeScript 1.7.1
(function() {
  angular.module("zj.namedRoutes", []).provider("$NamedRouteService", [
    "$locationProvider", function($locationProvider) {
      this.$get = [
        '$rootScope', '$route', '$location', '$log', function($rootScope, $route, $location, $log) {
          var MESSAGES, routeService, type;
          MESSAGES = {
            manyFound: function(name) {
              return 'Multiple routes matching ' + name + ' were found';
            },
            notFound: function(name) {
              return 'Route ' + routeName + ' not found';
            },
            unresolvable: function() {
              return 'Can not resolve undefined into a route';
            }
          };
          type = function(obj) {
            var classToType;
            if (obj === void 0 || obj === null) {
              return String(obj);
            }
            classToType = {
              '[object Boolean]': 'boolean',
              '[object Number]': 'number',
              '[object String]': 'string',
              '[object Function]': 'function',
              '[object Array]': 'array',
              '[object Date]': 'date',
              '[object RegExp]': 'regexp',
              '[object Object]': 'object'
            };
            return classToType[Object.prototype.toString.call(obj)];
          };
          return routeService = {
            isHtml5Mode: function() {
              var mode;
              mode = $locationProvider.html5Mode();
              if (typeof mode === 'boolean') {
                return mode;
              } else {
                return mode && mode.enabled;
              }
            },
            getPrefix: function() {
              var prefix;
              prefix = "";
              if (!this.isHtml5Mode()) {
                prefix = "#" + ($locationProvider.hashPrefix());
              }
              return prefix;
            },
            reverse: function(routeName, options) {
              var routes;
              routes = routeService.match(routeName);
              if (routes.length === 1) {
                return routeService.resolve(routes[0], options);
              } else if (routes.length === 0) {
                throw new Error(MESSAGES.notFound(routeName));
              } else {
                throw new Error(MESSAGES.manyFound(routeName));
              }
            },
            match: function(routeName) {
              var routes;
              routes = [];
              angular.forEach($route.routes, function(config, route) {
                if (config.name === routeName) {
                  return routes.push(route);
                }
              });
              return routes;
            },
            resolve: function(route, options) {
              var count, pattern;
              pattern = /(\:\w+\*?)/g;
              if (route === void 0) {
                throw new Error(MESSAGES.unresolvable(routeName));
              }
              count = 0;
              return this.getPrefix() + route.replace(pattern, function() {
                var match, offset, output;
                match = arguments[0], offset = arguments[arguments.length - 1];
                if (match.charAt(match.length - 1) === '*') {
                  match = match.substring(0, match.length - 1);
                }
                if (type(options) === 'array') {
                  output = options[count];
                  count++;
                } else if (type(options) === 'object') {
                  output = options[match.slice(1)];
                }
                return output;
              });
            }
          };
        }
      ];
      return this;
    }
  ]).directive('namedRoute', [
    '$log', '$NamedRouteService', function($log, $NamedRouteService) {
      return {
        restrict: "AC",
        link: function(scope, element, attributes) {
          var attribute, newKey, options, url;
          options = {};
          for (attribute in attributes) {
            if (!(attribute.indexOf('kwarg') === 0)) {
              continue;
            }
            newKey = attribute.slice(5);
            newKey = newKey.charAt(0).toLowerCase() + newKey.slice(1);
            options[newKey] = attributes[attribute];
          }
          if (attributes.args != null) {
            options = attributes.args.replace(/[\[\]\"\'\s]+/g, '').split(",");
          }
          url = $NamedRouteService.reverse(attributes.namedRoute, options);
          element.attr('href', url);
        }
      };
    }
  ]).filter('route', [
    '$route', '$NamedRouteService', function($route, $NamedRouteService) {
      return function(name, options) {
        return $NamedRouteService.reverse(name, options);
      };
    }
  ]);

}).call(this);

//# sourceMappingURL=angular-named-routes.map
